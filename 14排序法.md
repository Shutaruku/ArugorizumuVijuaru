## 選擇排序法 (Selection Sort)
```python

def selection_sort(A: List[int], N: int):
    # 定義找到子陣列中最小元素索引的函數
    def minimum(A: List[int], start: int, N: int):
        min_index = start
        for j in range(start + 1, N):
            if A[j] < A[min_index]:
                min_index = j
        return min_index
    
    # 進行選擇排序
    for i in range(N-1):
        # 找到從i到N之間最小元素的索引
        minj = minimum(A, i, N)
        # 交換當前元素與找到的最小元素
        A[i], A[minj] = A[minj], A[i]
```
### 時間複雜度
選擇排序的時間複雜度主要由兩層循環決定：
- 外層循環遍歷所有元素（除了最後一個，因為當只剩一個元素時，它必然是已經排序的），執行 \(N-1\) 次，其中 \(N\) 是數組的長度。
- 內層循環對當前元素之後的所有元素進行遍歷，以找到最小元素的索引。在最壞的情況下，第一次需要比較 \(N-1\) 次，然後是 \(N-2\) 次，一直到最後一次比較只需 1 次。

因此，選擇排序的總的比較次數可以通過求和公式計算為 \(\frac{N \times (N-1)}{2}\)，這表明選擇排序的時間複雜度為 \(O(N^2)\)，其中 \(N\) 是數組的長度。這意味着，如果數組的大小加倍，排序所需的時間將增加四倍。

### 空間複雜度
在空間複雜度方面，選擇排序是一個原地排序算法。除了用於交換的臨時變量外，它不需要額外的存儲空間。這意味着其空間複雜度為 \(O(1)\)，無論輸入數組的大小如何，所需的額外空間都保持不變。

總結，選擇排序算法的時間複雜度為 \(O(N^2)\)，空間複雜度為 \(O(1)\)。這使得選擇排序在處理小到中等大小的數組時是簡單且有效的，但對於大型數據集來説，它的效率並不高。

---

## 插入排序法 (Insertion Sort)
```python

def insertion(A: List[int], i: int) -> None:
    """
    將A[i]插入到已排序的子陣列A[0:i]中的適當位置
    """
    key = A[i] 
    # 變量保存了當前要進行插入操作的元素的值。
    # 這個值在後面的操作中會被比較，以找到它在已排序的子數組中的正確位置。
    
    j = i - 1
    # 初始化一個指針 j，它指向當前元素 A[i] 之前的元素（i-1）
    # 這是因為插入排序是將當前元素與它之前的已排序元素進行比較，並根據比較結果進行插入。
    
    while j >= 0 and A[j] > key:
    # 循環條件，執行以下兩個檢查：
    # 1、確保 j 沒有越界（j >= 0），即還在數組的有效範圍內。
    # 2、檢查當前指向的元素 A[j] 是否大於要插入的元素 key。
    # 如果是，這意味着 key 應該被插入到 A[j] 的前面，因為在插入排序中，我們希望數組是按升序排列的。
        A[j + 1] = A[j]
        # 如果上面的條件為真，即當前元素 A[j] 大於 key，
        # 則將 A[j] 向後移動一位到 A[j + 1] 的位置。這是為了為 key 騰出空間，從而可以將其插入到正確的位置。
        j -= 1
        # 將 j 減一，移動到下一個要比較的元素。這樣的移動是向前移動（即向數組的起始位置移動），因為我們正在將 key 與它之前的元素進行比較。
    A[j + 1] = key
    # 循環結束後（無論是因為找到了 key 應該插入的位置，還是因為 j 越界）
    # 將 key 插入到 A[j + 1] 的位置。注意，如果所有的 A[j] 都小於 key，那麼 j 會減到 -1，這時 key 應該被放在數組的第一個位置，即 A[0]。

def insertionSort(A: List[int], N: int) -> None:
    """
    對陣列A進行插入排序
    """
    for i in range(1, N):
        insertion(A, i)
```
### 時間複雜度
插入排序的時間複雜度依賴於輸入數據的初始順序。其分析如下：

- **最佳情況**：如果數組已經是排序好的，那麼每次插入操作只需要比較一次就能找到正確的位置，這意味着外層循環會遍歷 \(N-1\) 次，但內層循環（即`while`循環）幾乎不執行。因此，最佳情況下的時間複雜度為 \(O(N)\)。
- **最壞情況**：如果數組是逆序的，每次插入時，`key` 值需要與所有已排序的元素進行比較並移動，這導致最壞情況下的時間複雜度為 \(O(N^2)\)。
- **平均情況**：對於隨機順序的輸入，插入排序的平均時間複雜度也是 \(O(N^2)\)。雖然實際比較和移動的次數可能少於最壞情況，但它仍然是二次函數關係。

### 空間複雜度
插入排序是一種原地排序算法。除了用於循環的計數器和臨時變量 `key` 以存儲當前正在排序的元素之外，它不需要額外的存儲空間。這意味着其空間複雜度為 \(O(1)\)，即常數空間複雜度。

### 總結
- 時間複雜度：
  - 最佳情況：\(O(N)\)
  - 最壞情況和平均情況：\(O(N^2)\)
- 空間複雜度：\(O(1)\)

插入排序對於小數組或幾乎排序好的數組是有效的，但對於大規模亂序數組，由於其二次時間複雜度，其性能會顯著下降。